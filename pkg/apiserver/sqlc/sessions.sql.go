// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: sessions.sql

package sqlc

import (
	"context"
	"time"
)

const addSession = `-- name: AddSession :exec
INSERT INTO sessions (key, expiry, device_id, object_id)
VALUES ($1, $2, $3, $4)
`

type AddSessionParams struct {
	Key      string
	Expiry   time.Time
	DeviceID int32
	ObjectID string
}

func (q *Queries) AddSession(ctx context.Context, arg AddSessionParams) error {
	_, err := q.db.Exec(ctx, addSession,
		arg.Key,
		arg.Expiry,
		arg.DeviceID,
		arg.ObjectID,
	)
	return err
}

const addSessionAccessGroupID = `-- name: AddSessionAccessGroupID :exec
INSERT INTO session_access_group_ids (session_key, group_id)
VALUES ($1, $2)
`

type AddSessionAccessGroupIDParams struct {
	SessionKey string
	GroupID    string
}

func (q *Queries) AddSessionAccessGroupID(ctx context.Context, arg AddSessionAccessGroupIDParams) error {
	_, err := q.db.Exec(ctx, addSessionAccessGroupID, arg.SessionKey, arg.GroupID)
	return err
}

const getMostRecentDeviceSession = `-- name: GetMostRecentDeviceSession :one
SELECT s.key, s.expiry, s.device_id, s.object_id, d.id, d.username, d.serial, d.platform, d.healthy, d.last_updated, d.public_key, d.ip FROM sessions s
JOIN devices d ON d.id = s.device_id
WHERE s.device_id = $1
ORDER BY s.expiry DESC
LIMIT 1
`

type GetMostRecentDeviceSessionRow struct {
	Session Session
	Device  Device
}

func (q *Queries) GetMostRecentDeviceSession(ctx context.Context, deviceID int32) (*GetMostRecentDeviceSessionRow, error) {
	row := q.db.QueryRow(ctx, getMostRecentDeviceSession, deviceID)
	var i GetMostRecentDeviceSessionRow
	err := row.Scan(
		&i.Session.Key,
		&i.Session.Expiry,
		&i.Session.DeviceID,
		&i.Session.ObjectID,
		&i.Device.ID,
		&i.Device.Username,
		&i.Device.Serial,
		&i.Device.Platform,
		&i.Device.Healthy,
		&i.Device.LastUpdated,
		&i.Device.PublicKey,
		&i.Device.Ip,
	)
	return &i, err
}

const getSessionByKey = `-- name: GetSessionByKey :one
SELECT s.key, s.expiry, s.device_id, s.object_id, d.id, d.username, d.serial, d.platform, d.healthy, d.last_updated, d.public_key, d.ip FROM sessions s
JOIN devices d ON d.id = s.device_id WHERE s.key = $1
`

type GetSessionByKeyRow struct {
	Session Session
	Device  Device
}

func (q *Queries) GetSessionByKey(ctx context.Context, key string) (*GetSessionByKeyRow, error) {
	row := q.db.QueryRow(ctx, getSessionByKey, key)
	var i GetSessionByKeyRow
	err := row.Scan(
		&i.Session.Key,
		&i.Session.Expiry,
		&i.Session.DeviceID,
		&i.Session.ObjectID,
		&i.Device.ID,
		&i.Device.Username,
		&i.Device.Serial,
		&i.Device.Platform,
		&i.Device.Healthy,
		&i.Device.LastUpdated,
		&i.Device.PublicKey,
		&i.Device.Ip,
	)
	return &i, err
}

const getSessionGroupIDs = `-- name: GetSessionGroupIDs :many
SELECT group_id FROM session_access_group_ids WHERE session_key = $1
`

func (q *Queries) GetSessionGroupIDs(ctx context.Context, sessionKey string) ([]string, error) {
	rows, err := q.db.Query(ctx, getSessionGroupIDs, sessionKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var group_id string
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessions = `-- name: GetSessions :many
SELECT s.key, s.expiry, s.device_id, s.object_id, d.id, d.username, d.serial, d.platform, d.healthy, d.last_updated, d.public_key, d.ip FROM sessions s
JOIN devices d ON d.id = s.device_id WHERE s.expiry > NOW()
`

type GetSessionsRow struct {
	Session Session
	Device  Device
}

func (q *Queries) GetSessions(ctx context.Context) ([]*GetSessionsRow, error) {
	rows, err := q.db.Query(ctx, getSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetSessionsRow
	for rows.Next() {
		var i GetSessionsRow
		if err := rows.Scan(
			&i.Session.Key,
			&i.Session.Expiry,
			&i.Session.DeviceID,
			&i.Session.ObjectID,
			&i.Device.ID,
			&i.Device.Username,
			&i.Device.Serial,
			&i.Device.Platform,
			&i.Device.Healthy,
			&i.Device.LastUpdated,
			&i.Device.PublicKey,
			&i.Device.Ip,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
